package com.rohengiralt.minecraftservermanager.util.kubernetes

import io.kubernetes.client.common.KubernetesListObject
import io.kubernetes.client.common.KubernetesObject
import io.kubernetes.client.openapi.ApiCallback
import io.kubernetes.client.openapi.ApiResponse
import io.kubernetes.client.openapi.apis.AppsV1Api
import io.kubernetes.client.openapi.apis.CoreV1Api
import io.kubernetes.client.openapi.models.*
import io.kubernetes.client.util.CallGenerator
import io.kubernetes.client.util.CallGeneratorParams
import okhttp3.Call

/**
 * Wraps a request from the Kubernetes API Client in a generic way.
 * Useful for any generic operation on an arbitrary request,
 * since the API Client classes are autogenerated and feature
 * a lot of duplicated code without implementing any interfaces.
 * @param Resource the type of the resource returned by the request. For instance, `V1Pod`.
 * @param List the type of a list of the resource returned by the request. For instance, `V1PodList`.
 * @param Request the type of the request being wrapped
 */
class KubernetesRequest<Resource : KubernetesObject, List : KubernetesListObject, Request>(
    val original: Request,
    val pretty: (String) -> Request,
    val allowWatchBookmarks: (Boolean) -> Request,
    val _continue: (String) -> Request,
    val fieldSelector: (String) -> Request,
    val labelSelector: (String) -> Request,
    val limit: (Int) -> Request,
    val resourceVersion: (String) -> Request,
    val resourceVersionMatch: (String) -> Request,
    val sendInitialEvents: (Boolean) -> Request,
    val timeoutSeconds: (Int) -> Request,
    val watch: (Boolean) -> Request,
    val buildCall: (ApiCallback<*>?) -> Call,
    val execute: () -> List,
    val executeWithHttpInfo: () -> ApiResponse<List>,
    val executeAsync: (ApiCallback<List>) -> Call,
) : CallGenerator {
    fun buildCall(
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        @Suppress("LocalVariableName") _continue: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        sendInitialEvents: Boolean? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null,
        @Suppress("LocalVariableName") _callback: ApiCallback<*>? = null
    ): Call {
        pretty?.let(this.pretty)
        allowWatchBookmarks?.let(this.allowWatchBookmarks)
        _continue?.let(this._continue)
        fieldSelector?.let(this.fieldSelector)
        labelSelector?.let(this.labelSelector)
        limit?.let(this.limit)
        resourceVersion?.let(this.resourceVersion)
        resourceVersionMatch?.let(this.resourceVersionMatch)
        sendInitialEvents?.let(this.sendInitialEvents)
        timeoutSeconds?.let(this.timeoutSeconds)
        watch?.let(this.watch)

        return buildCall(_callback)
    }

    override fun generate(params: CallGeneratorParams): Call = buildCall(
        resourceVersion = params.resourceVersion,
        timeoutSeconds = params.timeoutSeconds,
        watch = params.watch,
    )
}

// The following functions convert various API Client requests into a KubernetesRequest.
// Because these requests do not implement any shared interface,
// one extension function must be written for each API Client request of interest.

@Suppress("DuplicatedCode") fun CoreV1Api.APIlistNamespacedPodRequest.asRequest(): KubernetesRequest<V1Pod, V1PodList, CoreV1Api.APIlistNamespacedPodRequest> =
    KubernetesRequest(original = this, pretty = ::pretty, allowWatchBookmarks = ::allowWatchBookmarks, _continue = ::_continue, fieldSelector = ::fieldSelector, labelSelector = ::labelSelector, limit = ::limit, resourceVersion = ::resourceVersion, resourceVersionMatch = ::resourceVersionMatch, sendInitialEvents = ::sendInitialEvents, timeoutSeconds = ::timeoutSeconds, watch = ::watch, buildCall = ::buildCall, execute = ::execute, executeWithHttpInfo = ::executeWithHttpInfo, executeAsync = ::executeAsync)
@Suppress("DuplicatedCode") fun CoreV1Api.APIlistNodeRequest.asRequest(): KubernetesRequest<V1Node, V1NodeList, CoreV1Api.APIlistNodeRequest> =
    KubernetesRequest(original = this, pretty = ::pretty, allowWatchBookmarks = ::allowWatchBookmarks, _continue = ::_continue, fieldSelector = ::fieldSelector, labelSelector = ::labelSelector, limit = ::limit, resourceVersion = ::resourceVersion, resourceVersionMatch = ::resourceVersionMatch, sendInitialEvents = ::sendInitialEvents, timeoutSeconds = ::timeoutSeconds, watch = ::watch, buildCall = ::buildCall, execute = ::execute, executeWithHttpInfo = ::executeWithHttpInfo, executeAsync = ::executeAsync)

@Suppress("DuplicatedCode") fun AppsV1Api.APIlistNamespacedDeploymentRequest.asRequest(): KubernetesRequest<V1Deployment, V1DeploymentList, AppsV1Api.APIlistNamespacedDeploymentRequest> =
    KubernetesRequest(original = this, pretty = ::pretty, allowWatchBookmarks = ::allowWatchBookmarks, _continue = ::_continue, fieldSelector = ::fieldSelector, labelSelector = ::labelSelector, limit = ::limit, resourceVersion = ::resourceVersion, resourceVersionMatch = ::resourceVersionMatch, sendInitialEvents = ::sendInitialEvents, timeoutSeconds = ::timeoutSeconds, watch = ::watch, buildCall = ::buildCall, execute = ::execute, executeWithHttpInfo = ::executeWithHttpInfo, executeAsync = ::executeAsync)